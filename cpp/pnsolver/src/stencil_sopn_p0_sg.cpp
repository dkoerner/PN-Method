// This file was generated by stencil.py

#include <PNSystem.h>

void stencil_sopn_p0_sg(PNSystem::Stencil::Context& ctx)
{
	V3i vi = ctx.getVoxelCoord();
	V3d vd = vi.cast<double>();
	const Domain& domain = ctx.getDomain();
	const PNSystem::Fields& fields = ctx.getFields();
	V3d h_inv( 1.0/(1*domain.getVoxelSize()[0]), 1.0/(1*domain.getVoxelSize()[1]), 1.0/(1*domain.getVoxelSize()[2]) );

	Eigen::Matrix<std::complex<double>, 1, 1> S;
	S.coeffRef(0, 0) = std::complex<double>(1.0, 0.0);
	Eigen::Matrix<std::complex<double>, 1, 1> SInv;
	SInv.coeffRef(0, 0) = std::complex<double>(1.0, 0.0);

	//Producing complex-valued matrices =============
	//M_0dxdxL + M_1dxdyL + M_2dxdzL + M_3dydxL + M_4dydyL + M_5dydzL + M_6dzdxL + M_7dzdyL + M_8dzdzL + M_9L + M_10dxL + M_11dyL + M_12dzL = b

	//M_0 ---
	// is constant

	//M_1 ---
	// is constant

	//M_2 ---
	// all components vanish

	//M_3 ---
	// is constant

	//M_4 ---
	// is constant

	//M_5 ---
	// all components vanish

	//M_6 ---
	// all components vanish

	//M_7 ---
	// all components vanish

	//M_8 ---
	// is constant

	//M_9 ---
	Eigen::Matrix<double, 1, 1> M_9_real_staggered[4];
	for( int i=0;i<4;++i )
	{
		Eigen::Matrix<std::complex<double>, 1, 1> M_9;
		M_9(0, 0) = (std::pow(fields.sigma_t->eval(domain.voxelToWorld(vd+ctx.getGridOffset2(i))), 2)+
			-(fields.sigma_t->eval(domain.voxelToWorld(vd+ctx.getGridOffset2(i)))*fields.sigma_s->eval(domain.voxelToWorld(vd+ctx.getGridOffset2(i)))*fields.f_p->eval(0, 0, domain.voxelToWorld(vd+ctx.getGridOffset2(i)))));
		M_9_real_staggered[i] = (S*M_9*SInv).real();
	}
	Eigen::Matrix<double, 1, 1> M_9_real;
	M_9_real.row(0) = M_9_real_staggered[2].row(0);

	//M_10 ---
	// all components vanish

	//M_11 ---
	// all components vanish

	//M_12 ---
	// all components vanish

	//b ---
	Eigen::Matrix<double, 1, 1> b_real_staggered[4];
	for( int i=0;i<4;++i )
	{
		Eigen::Matrix<std::complex<double>, 1, 1> b;
		b(0, 0) = (fields.sigma_t->eval(domain.voxelToWorld(vd+ctx.getGridOffset2(i)))*fields.q->eval(0, 0, domain.voxelToWorld(vd+ctx.getGridOffset2(i))));
		b_real_staggered[i] = (S*b).real();
	}
	Eigen::Matrix<double, 1, 1> b_real;
	b_real.row(0) = b_real_staggered[2].row(0);

	// Assembling global system =============
	ctx.coeff_A( 0, vi + V3i(-1,0,0), 0 ) += (h_inv[0]*h_inv[0]*-0.333333333333);
	ctx.coeff_A( 0, vi + V3i(0,0,0), 0 ) += -(h_inv[0]*h_inv[0]*-0.333333333333);
	ctx.coeff_A( 0, vi + V3i(0,0,0), 0 ) += -(h_inv[0]*h_inv[0]*-0.333333333333);
	ctx.coeff_A( 0, vi + V3i(1,0,0), 0 ) += (h_inv[0]*h_inv[0]*-0.333333333333);
	ctx.coeff_A( 0, vi + V3i(0,-1,0), 0 ) += (h_inv[1]*h_inv[1]*-0.333333333333);
	ctx.coeff_A( 0, vi + V3i(0,0,0), 0 ) += -(h_inv[1]*h_inv[1]*-0.333333333333);
	ctx.coeff_A( 0, vi + V3i(0,0,0), 0 ) += -(h_inv[1]*h_inv[1]*-0.333333333333);
	ctx.coeff_A( 0, vi + V3i(0,1,0), 0 ) += (h_inv[1]*h_inv[1]*-0.333333333333);
	ctx.coeff_A( 0, vi + V3i(0,0,0), 0 ) += M_9_real.coeffRef(0, 0);
	ctx.coeff_b( 0 ) += b_real.coeffRef(0, 0);
}
V3i stencil_sopn_p0_sg_get_offset(int coeff)
{
	switch(coeff)
	{
		case 0:return V3i(1, 1, 1);break;
		default:throw std::runtime_error("unexpected coefficient index");break;
	};
}
REGISTER_STENCIL(stencil_sopn_p0_sg, 0, 1, 1)
