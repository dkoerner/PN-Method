#include <Image.h>



#include <OpenEXR/ImfInputFile.h>
#include <OpenEXR/ImfOutputFile.h>
#include <OpenEXR/ImfChannelList.h>
#include <OpenEXR/ImfStringAttribute.h>
#include <OpenEXR/ImfVersion.h>
#include <OpenEXR/ImfHeader.h>
#include <OpenEXR/ImfIO.h>









Image::Image(const Vector2i &size)
	: m_data(size.y(), size.x())
{
}

Image::Image(const Image& image)
	: m_data(image.getResolution()[1], image.getResolution()[0])
{
	//memcpy( m_data.data(), image.data(), sizeof(V3d)*m_data.rows()*m_data.cols() );
	memcpy( m_data.data(), image.data(), sizeof(V3d)*m_data.rows()*m_data.cols() );
}


const Eigen::Vector3d* Image::data()const
{
	return m_data.data();
}

Image::Base& Image::getArray()
{
	return m_data;
}

Eigen::Vector3d& Image::pixel( int x, int y )
{
	return m_data.coeffRef(y, x);
}

void Image::save(const std::string& filename)
{
	std::cout << "saving image to " << filename << " resolution=" << getResolution().toString() << std::endl;

	V2i res = getResolution();
	Imf::Header header(res[0], res[1]);
	header.insert("comments", Imf::StringAttribute("generated by renderer"));

	Imf::ChannelList &channels = header.channels();
	channels.insert("R", Imf::Channel(Imf::FLOAT));
	channels.insert("G", Imf::Channel(Imf::FLOAT));
	channels.insert("B", Imf::Channel(Imf::FLOAT));

	Imf::FrameBuffer frameBuffer;
	size_t compStride = sizeof(float),
		   pixelStride = 3 * compStride,
		   rowStride = pixelStride * res[0];

	// exr coordinate system has its origin at the top-left corner of the image,
	// while we have the origin at the bottom left of the image
	// therefore we need to flip the image data vertically
	Base img_flipped_vertically = m_data.colwise().reverse();
	//Base img_flipped_vertically = m_data;

	// we convert to float
	int size = res[0]*res[1]*3;
	std::vector<float> converted( size );
	double* org = img_flipped_vertically.data()->data();
	for( int i=0;i<size;++i )
		converted[i] = float(org[i]);


	char *ptr = reinterpret_cast<char *>(converted.data());

	frameBuffer.insert("R", Imf::Slice(Imf::FLOAT, ptr, pixelStride, rowStride)); ptr += compStride;
	frameBuffer.insert("G", Imf::Slice(Imf::FLOAT, ptr, pixelStride, rowStride)); ptr += compStride;
	frameBuffer.insert("B", Imf::Slice(Imf::FLOAT, ptr, pixelStride, rowStride));

	Imf::OutputFile file(filename.c_str(), header);
	file.setFrameBuffer(frameBuffer);
	file.writePixels(res[1]);
}

V2i Image::getResolution()const
{
	return V2i(m_data.cols(), m_data.rows());
}

std::string Image::toString()const
{
	std::ostringstream ss;
	ss << "Image resolution=" << getResolution().toString() << std::endl;
	return ss.str();
}
