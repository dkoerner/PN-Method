// This file was generated by stencil.py

#include <PNSystem.h>

void stencil_fopn_p2_cg(PNSystem::Stencil::Context& ctx)
{
	V3i vi = ctx.getVoxelCoord();
	V3d vd = vi.cast<double>();
	const Domain& domain = ctx.getDomain();
	const PNSystem::Fields& fields = ctx.getFields();
	V3d h_inv( 1.0/(2*domain.getVoxelSize()[0]), 1.0/(2*domain.getVoxelSize()[1]), 1.0/(2*domain.getVoxelSize()[2]) );

	Eigen::Matrix<std::complex<double>, 6, 6> S;
	S.coeffRef(0, 0) = std::complex<double>(1.0, 0.0);
	S.coeffRef(1, 1) = std::complex<double>(0.7071067811865475, 0.0);
	S.coeffRef(1, 2) = std::complex<double>(-0.7071067811865475, 0.0);
	S.coeffRef(2, 1) = std::complex<double>(-0.0, -0.7071067811865475);
	S.coeffRef(2, 2) = std::complex<double>(-0.0, -0.7071067811865475);
	S.coeffRef(3, 3) = std::complex<double>(0.7071067811865475, 0.0);
	S.coeffRef(3, 5) = std::complex<double>(0.7071067811865475, 0.0);
	S.coeffRef(4, 3) = std::complex<double>(-0.0, -0.7071067811865475);
	S.coeffRef(4, 5) = std::complex<double>(0.0, 0.7071067811865475);
	S.coeffRef(5, 4) = std::complex<double>(1.0, 0.0);
	Eigen::Matrix<std::complex<double>, 6, 6> SInv;
	SInv.coeffRef(0, 0) = std::complex<double>(1.0, 0.0);
	SInv.coeffRef(1, 1) = std::complex<double>(0.7071067811865476, 0.0);
	SInv.coeffRef(1, 2) = std::complex<double>(0.0, 0.7071067811865476);
	SInv.coeffRef(2, 1) = std::complex<double>(-0.7071067811865476, 0.0);
	SInv.coeffRef(2, 2) = std::complex<double>(-0.0, 0.7071067811865476);
	SInv.coeffRef(3, 3) = std::complex<double>(0.7071067811865476, 0.0);
	SInv.coeffRef(3, 4) = std::complex<double>(0.0, 0.7071067811865476);
	SInv.coeffRef(4, 5) = std::complex<double>(1.0, 0.0);
	SInv.coeffRef(5, 3) = std::complex<double>(0.7071067811865476, 0.0);
	SInv.coeffRef(5, 4) = std::complex<double>(0.0, -0.7071067811865476);

	//Producing complex-valued matrices =============
	//M_0dxL + M_1dyL + M_2dzL + M_3L = b

	//M_0 ---
	// is constant

	//M_1 ---
	// is constant

	//M_2 ---
	// all components vanish

	//M_3 ---
	Eigen::Matrix<double, 6, 6> M_3_real_staggered[4];
	for( int i=0;i<4;++i )
	{
		Eigen::Matrix<std::complex<double>, 6, 6> M_3;
		M_3(0, 0) = (fields.sigma_t->eval(domain.voxelToWorld(vd+ctx.getGridOffset2(i)))+
			-(fields.sigma_s->eval(domain.voxelToWorld(vd+ctx.getGridOffset2(i)))*fields.f_p->eval(0, 0, domain.voxelToWorld(vd+ctx.getGridOffset2(i)))));
		M_3(1, 1) = (fields.sigma_t->eval(domain.voxelToWorld(vd+ctx.getGridOffset2(i)))+
			-(fields.sigma_s->eval(domain.voxelToWorld(vd+ctx.getGridOffset2(i)))*fields.f_p->eval(1, 0, domain.voxelToWorld(vd+ctx.getGridOffset2(i)))));
		M_3(2, 2) = (fields.sigma_t->eval(domain.voxelToWorld(vd+ctx.getGridOffset2(i)))+
			-(fields.sigma_s->eval(domain.voxelToWorld(vd+ctx.getGridOffset2(i)))*fields.f_p->eval(1, 0, domain.voxelToWorld(vd+ctx.getGridOffset2(i)))));
		M_3(3, 3) = (fields.sigma_t->eval(domain.voxelToWorld(vd+ctx.getGridOffset2(i)))+
			-(fields.sigma_s->eval(domain.voxelToWorld(vd+ctx.getGridOffset2(i)))*fields.f_p->eval(2, 0, domain.voxelToWorld(vd+ctx.getGridOffset2(i)))));
		M_3(4, 4) = (fields.sigma_t->eval(domain.voxelToWorld(vd+ctx.getGridOffset2(i)))+
			-(fields.sigma_s->eval(domain.voxelToWorld(vd+ctx.getGridOffset2(i)))*fields.f_p->eval(2, 0, domain.voxelToWorld(vd+ctx.getGridOffset2(i)))));
		M_3(5, 5) = (fields.sigma_t->eval(domain.voxelToWorld(vd+ctx.getGridOffset2(i)))+
			-(fields.sigma_s->eval(domain.voxelToWorld(vd+ctx.getGridOffset2(i)))*fields.f_p->eval(2, 0, domain.voxelToWorld(vd+ctx.getGridOffset2(i)))));
		M_3_real_staggered[i] = (S*M_3*SInv).real();
	}
	Eigen::Matrix<double, 6, 6> M_3_real;
	M_3_real.row(0) = M_3_real_staggered[2].row(0);
	M_3_real.row(1) = M_3_real_staggered[2].row(1);
	M_3_real.row(2) = M_3_real_staggered[2].row(2);
	M_3_real.row(3) = M_3_real_staggered[2].row(3);
	M_3_real.row(4) = M_3_real_staggered[2].row(4);
	M_3_real.row(5) = M_3_real_staggered[2].row(5);

	//b ---
	Eigen::Matrix<double, 6, 1> b_real_staggered[4];
	for( int i=0;i<4;++i )
	{
		Eigen::Matrix<std::complex<double>, 6, 1> b;
		b(0, 0) = fields.q->eval(0, 0, domain.voxelToWorld(vd+ctx.getGridOffset2(i)));
		b(1, 0) = fields.q->eval(1, -1, domain.voxelToWorld(vd+ctx.getGridOffset2(i)));
		b(2, 0) = fields.q->eval(1, 1, domain.voxelToWorld(vd+ctx.getGridOffset2(i)));
		b(3, 0) = fields.q->eval(2, -2, domain.voxelToWorld(vd+ctx.getGridOffset2(i)));
		b(4, 0) = fields.q->eval(2, 0, domain.voxelToWorld(vd+ctx.getGridOffset2(i)));
		b(5, 0) = fields.q->eval(2, 2, domain.voxelToWorld(vd+ctx.getGridOffset2(i)));
		b_real_staggered[i] = (S*b).real();
	}
	Eigen::Matrix<double, 6, 1> b_real;
	b_real.row(0) = b_real_staggered[2].row(0);
	b_real.row(1) = b_real_staggered[2].row(1);
	b_real.row(2) = b_real_staggered[2].row(2);
	b_real.row(3) = b_real_staggered[2].row(3);
	b_real.row(4) = b_real_staggered[2].row(4);
	b_real.row(5) = b_real_staggered[2].row(5);

	// Assembling global system =============
	ctx.coeff_A( 1, vi + V3i(-1,0,0), 0 ) += -(h_inv[0]*0.57735026919);
	ctx.coeff_A( 1, vi + V3i(1,0,0), 0 ) += (h_inv[0]*0.57735026919);
	ctx.coeff_A( 0, vi + V3i(-1,0,0), 1 ) += -(h_inv[0]*0.57735026919);
	ctx.coeff_A( 0, vi + V3i(1,0,0), 1 ) += (h_inv[0]*0.57735026919);
	ctx.coeff_A( 3, vi + V3i(-1,0,0), 1 ) += -(h_inv[0]*0.4472135955);
	ctx.coeff_A( 3, vi + V3i(1,0,0), 1 ) += (h_inv[0]*0.4472135955);
	ctx.coeff_A( 5, vi + V3i(-1,0,0), 1 ) += -(h_inv[0]*-0.258198889747);
	ctx.coeff_A( 5, vi + V3i(1,0,0), 1 ) += (h_inv[0]*-0.258198889747);
	ctx.coeff_A( 4, vi + V3i(-1,0,0), 2 ) += -(h_inv[0]*0.4472135955);
	ctx.coeff_A( 4, vi + V3i(1,0,0), 2 ) += (h_inv[0]*0.4472135955);
	ctx.coeff_A( 1, vi + V3i(-1,0,0), 3 ) += -(h_inv[0]*0.4472135955);
	ctx.coeff_A( 1, vi + V3i(1,0,0), 3 ) += (h_inv[0]*0.4472135955);
	ctx.coeff_A( 2, vi + V3i(-1,0,0), 4 ) += -(h_inv[0]*0.4472135955);
	ctx.coeff_A( 2, vi + V3i(1,0,0), 4 ) += (h_inv[0]*0.4472135955);
	ctx.coeff_A( 1, vi + V3i(-1,0,0), 5 ) += -(h_inv[0]*-0.258198889747);
	ctx.coeff_A( 1, vi + V3i(1,0,0), 5 ) += (h_inv[0]*-0.258198889747);
	ctx.coeff_A( 2, vi + V3i(0,-1,0), 0 ) += -(h_inv[1]*0.57735026919);
	ctx.coeff_A( 2, vi + V3i(0,1,0), 0 ) += (h_inv[1]*0.57735026919);
	ctx.coeff_A( 4, vi + V3i(0,-1,0), 1 ) += -(h_inv[1]*0.4472135955);
	ctx.coeff_A( 4, vi + V3i(0,1,0), 1 ) += (h_inv[1]*0.4472135955);
	ctx.coeff_A( 0, vi + V3i(0,-1,0), 2 ) += -(h_inv[1]*0.57735026919);
	ctx.coeff_A( 0, vi + V3i(0,1,0), 2 ) += (h_inv[1]*0.57735026919);
	ctx.coeff_A( 3, vi + V3i(0,-1,0), 2 ) += -(h_inv[1]*-0.4472135955);
	ctx.coeff_A( 3, vi + V3i(0,1,0), 2 ) += (h_inv[1]*-0.4472135955);
	ctx.coeff_A( 5, vi + V3i(0,-1,0), 2 ) += -(h_inv[1]*-0.258198889747);
	ctx.coeff_A( 5, vi + V3i(0,1,0), 2 ) += (h_inv[1]*-0.258198889747);
	ctx.coeff_A( 2, vi + V3i(0,-1,0), 3 ) += -(h_inv[1]*-0.4472135955);
	ctx.coeff_A( 2, vi + V3i(0,1,0), 3 ) += (h_inv[1]*-0.4472135955);
	ctx.coeff_A( 1, vi + V3i(0,-1,0), 4 ) += -(h_inv[1]*0.4472135955);
	ctx.coeff_A( 1, vi + V3i(0,1,0), 4 ) += (h_inv[1]*0.4472135955);
	ctx.coeff_A( 2, vi + V3i(0,-1,0), 5 ) += -(h_inv[1]*-0.258198889747);
	ctx.coeff_A( 2, vi + V3i(0,1,0), 5 ) += (h_inv[1]*-0.258198889747);
	ctx.coeff_A( 0, vi + V3i(0,0,0), 0 ) += M_3_real.coeffRef(0, 0);
	ctx.coeff_A( 1, vi + V3i(0,0,0), 1 ) += M_3_real.coeffRef(1, 1);
	ctx.coeff_A( 2, vi + V3i(0,0,0), 2 ) += M_3_real.coeffRef(2, 2);
	ctx.coeff_A( 3, vi + V3i(0,0,0), 3 ) += M_3_real.coeffRef(3, 3);
	ctx.coeff_A( 4, vi + V3i(0,0,0), 4 ) += M_3_real.coeffRef(4, 4);
	ctx.coeff_A( 5, vi + V3i(0,0,0), 5 ) += M_3_real.coeffRef(5, 5);
	ctx.coeff_b( 0 ) += b_real.coeffRef(0, 0);
	ctx.coeff_b( 1 ) += b_real.coeffRef(1, 0);
	ctx.coeff_b( 2 ) += b_real.coeffRef(2, 0);
	ctx.coeff_b( 3 ) += b_real.coeffRef(3, 0);
	ctx.coeff_b( 4 ) += b_real.coeffRef(4, 0);
	ctx.coeff_b( 5 ) += b_real.coeffRef(5, 0);
}
V3i stencil_fopn_p2_cg_get_offset(int coeff)
{
	switch(coeff)
	{
		case 0:return V3i(1, 1, 1);break;
		case 1:return V3i(1, 1, 1);break;
		case 2:return V3i(1, 1, 1);break;
		case 3:return V3i(1, 1, 1);break;
		case 4:return V3i(1, 1, 1);break;
		case 5:return V3i(1, 1, 1);break;
		default:throw std::runtime_error("unexpected coefficient index");break;
	};
}
REGISTER_STENCIL(stencil_fopn_p2_cg, 2, 6, 1)
